pub mod mixed;
mod utils;

use std::marker::PhantomData;
use std::time::Instant;
use ark_serialize::CanonicalDeserialize;
use ark_serialize::CanonicalSerialize;
use ark_serialize::Valid;
use blake2::Blake2s256;
use ministark::Matrix;
use ministark::hash::ElementHashFn;
use ministark::hash::HashFn;
use ministark::merkle::HashedLeafConfig;
use ministark::merkle::MatrixMerkleTree;
use ministark::merkle::MerkleTree;
use core::iter::zip;
use ministark::merkle::MerkleTreeConfig;
use ministark::merkle::MerkleTreeImpl;
use ministark::merkle::MerkleView;
use ministark::utils::SerdeOutput;
use ministark::merkle::Error;
use ministark_gpu::fields::p3618502788666131213697322783095070105623107215331596699973092056135872020481::ark::Fp;
use mixed::FriendlyMerkleTreeConfig;
use mixed::MixedHashMerkleTreeImpl;
use mixed::MixedMerkleDigest;
use crate::hash::blake2s::MaskedBlake2sHashFn;

/// Friendly merkle tree is used as the merkle tree when generating recursive
/// STARK proofs.
///
/// When committing to matricies this merkle tree has a couple of variants:
/// - **Single column matrix:** The leaves of the merkle tree are the column
///   values and an algebraic hash function is used for hashing all internal
///   nodes of the merkle tree.
/// - **Multi column matrix:** The rows are always hashed with Blake2s. These
///   hashes become the leaves of the merkle tree. The internal nodes of the
///   merkle tree can be generated by two different hash functions. The
///   `N_FRIENDLY_LAYERS` parameter specifies how many of the high layers will
///   be hashed using an algebraic hash function (efficient for the verifier but
///   slow for the prover). The remaining lower layers are hashed with Blake2s
///   which is less a less efficient hash function for the verifier but can be
///   >100x faster for the prover.
pub enum FriendlyMerkleTree<const N_FRIENDLY_LAYERS: u32, H: ElementHashFn<Fp>>
where
    H::Digest: From<Fp>,
{
    MultiCol(MixedHashMerkleTreeImpl<FriendlyMerkleTreeConfig<N_FRIENDLY_LAYERS, H>>),
    SingleCol(MerkleTreeImpl<UnhashedLeafConfig<H>>),
}

impl<const N_FRIENDLY_LAYERS: u32, H: ElementHashFn<Fp>> Clone
    for FriendlyMerkleTree<N_FRIENDLY_LAYERS, H>
where
    H::Digest: From<Fp>,
{
    fn clone(&self) -> Self {
        match self {
            Self::MultiCol(mt) => Self::MultiCol(mt.clone()),
            Self::SingleCol(mt) => Self::SingleCol(mt.clone()),
        }
    }
}

impl<const N_FRIENDLY_LAYERS: u32, H: ElementHashFn<Fp>> MerkleTree
    for FriendlyMerkleTree<N_FRIENDLY_LAYERS, H>
where
    H::Digest: From<Fp>,
{
    type Proof = FriendlyMerkleTreeProof<H>;
    type Root = MixedMerkleDigest<H::Digest, SerdeOutput<Blake2s256>>;

    fn root(&self) -> Self::Root {
        match self {
            Self::MultiCol(mt) => mt.root(),
            Self::SingleCol(mt) => MixedMerkleDigest::HighLevel(mt.root()),
        }
    }

    fn prove(&self, indices: &[usize]) -> Result<FriendlyMerkleTreeProof<H>, Error> {
        Ok(match self {
            Self::MultiCol(mt) => FriendlyMerkleTreeProof::MultiCol(mt.prove(indices)?),
            Self::SingleCol(mt) => FriendlyMerkleTreeProof::SingleCol(mt.prove(indices)?),
        })
    }

    fn verify(root: &Self::Root, proof: Self::Proof, indices: &[usize]) -> Result<(), Error> {
        match proof {
            FriendlyMerkleTreeProof::MultiCol(proof) => MixedHashMerkleTreeImpl::<
                FriendlyMerkleTreeConfig<N_FRIENDLY_LAYERS, H>,
            >::verify(root, proof, indices),
            FriendlyMerkleTreeProof::SingleCol(proof) => {
                let MixedMerkleDigest::HighLevel(root) = root else {
                    unreachable!()
                };
                MerkleTreeImpl::<UnhashedLeafConfig<H>>::verify(root, proof, indices)
            }
        }
    }

    fn security_level_bits() -> u32 {
        H::COLLISION_RESISTANCE.min(MaskedBlake2sHashFn::<20>::COLLISION_RESISTANCE)
    }
}

impl<const N_FRIENDLY_LAYERS: u32, H: ElementHashFn<Fp>> MatrixMerkleTree<Fp>
    for FriendlyMerkleTree<N_FRIENDLY_LAYERS, H>
where
    H::Digest: From<Fp>,
{
    fn from_matrix(matrix: &Matrix<Fp>) -> Self {
        match matrix.num_cols() {
            0 => unreachable!(),
            1 => {
                // matrix is single column so the column becomes the leaves
                let leaves = matrix[0].to_vec();
                Self::SingleCol(MerkleTreeImpl::new(leaves).unwrap())
            }
            _ => {
                let now = Instant::now();
                let row_hashes = utils::hash_rows::<MaskedBlake2sHashFn<20>>(matrix);
                println!("Hashing rows: {:?}", now.elapsed());
                Self::MultiCol(MerkleTreeImpl::new(row_hashes).unwrap())
            }
        }
    }

    fn verify_rows(
        root: &Self::Root,
        row_ids: &[usize],
        rows: &[impl AsRef<[Fp]>],
        proof: Self::Proof,
    ) -> Result<(), Error> {
        // remove duplicates and sort
        // TODO: little bit of duplication from MatrixMerkleTreeImpl in miniSTARK
        let mut instances = zip(row_ids, rows).collect::<Vec<_>>();
        instances.sort_unstable_by(|(a, _), (b, _)| a.cmp(b));
        instances.dedup_by(|(a, _), (b, _)| a == b);

        let (indices, rows): (Vec<_>, Vec<_>) = instances.into_iter().unzip();

        // check leaves
        match &proof {
            FriendlyMerkleTreeProof::SingleCol(single_col_proof) => {
                let mut initial_leaves = Vec::new();
                for row in rows {
                    match row.as_ref() {
                        &[v] => initial_leaves.push(v),
                        _ => return Err(Error::InvalidProof),
                    }
                }
                if single_col_proof.initial_leaves != initial_leaves {
                    return Err(Error::InvalidProof);
                }
            }
            FriendlyMerkleTreeProof::MultiCol(multi_col_proof) => {
                let initial_leaves = rows
                    .into_iter()
                    .map(|r| MaskedBlake2sHashFn::<20>::hash_elements(r.as_ref().iter().copied()))
                    .collect::<Vec<_>>();
                if multi_col_proof.initial_leaves != initial_leaves {
                    return Err(Error::InvalidProof);
                }
            }
        }

        Self::verify(root, proof, &indices)
    }
}

pub enum FriendlyMerkleTreeProof<H: ElementHashFn<Fp>> {
    MultiCol(
        MerkleView<MixedMerkleDigest<H::Digest, SerdeOutput<Blake2s256>>, SerdeOutput<Blake2s256>>,
    ),
    SingleCol(MerkleView<H::Digest, Fp>),
}

impl<H: ElementHashFn<Fp>> FriendlyMerkleTreeProof<H> {
    const MULTI_COL_DISCRIMINANT: u8 = 0;
    const SINGLE_COL_DISCRIMINANT: u8 = 1;
}

impl<H: ElementHashFn<Fp>> Clone for FriendlyMerkleTreeProof<H> {
    fn clone(&self) -> Self {
        match self {
            Self::MultiCol(proof) => Self::MultiCol(proof.clone()),
            Self::SingleCol(proof) => Self::SingleCol(proof.clone()),
        }
    }
}

impl<H: ElementHashFn<Fp>> CanonicalSerialize for FriendlyMerkleTreeProof<H> {
    fn serialize_with_mode<W: ark_serialize::Write>(
        &self,
        mut writer: W,
        compress: ark_serialize::Compress,
    ) -> Result<(), ark_serialize::SerializationError> {
        match self {
            Self::MultiCol(proof) => {
                Self::MULTI_COL_DISCRIMINANT.serialize_with_mode(&mut writer, compress)?;
                proof.serialize_with_mode(writer, compress)
            }
            Self::SingleCol(proof) => {
                Self::SINGLE_COL_DISCRIMINANT.serialize_with_mode(&mut writer, compress)?;
                proof.serialize_with_mode(writer, compress)
            }
        }
    }

    fn serialized_size(&self, compress: ark_serialize::Compress) -> usize {
        1 + match self {
            Self::MultiCol(proof) => proof.serialized_size(compress),
            Self::SingleCol(proof) => proof.serialized_size(compress),
        }
    }
}

impl<H: ElementHashFn<Fp>> Valid for FriendlyMerkleTreeProof<H> {
    fn check(&self) -> Result<(), ark_serialize::SerializationError> {
        Ok(())
    }
}

impl<H: ElementHashFn<Fp>> CanonicalDeserialize for FriendlyMerkleTreeProof<H> {
    fn deserialize_with_mode<R: ark_serialize::Read>(
        mut reader: R,
        compress: ark_serialize::Compress,
        validate: ark_serialize::Validate,
    ) -> Result<Self, ark_serialize::SerializationError> {
        let variant = u8::deserialize_with_mode(&mut reader, compress, validate)?;
        Ok(match variant {
            Self::MULTI_COL_DISCRIMINANT => {
                Self::MultiCol(<_>::deserialize_with_mode(reader, compress, validate)?)
            }
            Self::SINGLE_COL_DISCRIMINANT => {
                Self::SingleCol(<_>::deserialize_with_mode(reader, compress, validate)?)
            }
            _ => Err(ark_serialize::SerializationError::InvalidData)?,
        })
    }
}

pub enum LeafVariantMerkleTree<H: ElementHashFn<Fp>> {
    Hashed(MerkleTreeImpl<HashedLeafConfig<H>>),
    Unhashed(MerkleTreeImpl<UnhashedLeafConfig<H>>),
}

impl<H: ElementHashFn<Fp>> Clone for LeafVariantMerkleTree<H> {
    fn clone(&self) -> Self {
        match self {
            Self::Hashed(mt) => Self::Hashed(mt.clone()),
            Self::Unhashed(mt) => Self::Unhashed(mt.clone()),
        }
    }
}

impl<H: ElementHashFn<Fp>> MerkleTree for LeafVariantMerkleTree<H> {
    type Proof = LeafVariantMerkleTreeProof<H>;
    type Root = H::Digest;

    fn root(&self) -> Self::Root {
        match self {
            Self::Hashed(mt) => mt.root(),
            Self::Unhashed(mt) => mt.root(),
        }
    }

    fn prove(&self, indices: &[usize]) -> Result<LeafVariantMerkleTreeProof<H>, Error> {
        Ok(match self {
            Self::Hashed(mt) => LeafVariantMerkleTreeProof::Hashed(mt.prove(indices)?),
            Self::Unhashed(mt) => LeafVariantMerkleTreeProof::Unhashed(mt.prove(indices)?),
        })
    }

    fn verify(root: &Self::Root, proof: Self::Proof, indices: &[usize]) -> Result<(), Error> {
        match proof {
            LeafVariantMerkleTreeProof::Hashed(proof) => {
                MerkleTreeImpl::<HashedLeafConfig<H>>::verify(root, proof, indices)
            }
            LeafVariantMerkleTreeProof::Unhashed(proof) => {
                MerkleTreeImpl::<UnhashedLeafConfig<H>>::verify(root, proof, indices)
            }
        }
    }

    fn security_level_bits() -> u32 {
        H::COLLISION_RESISTANCE
    }
}

impl<H: ElementHashFn<Fp>> MatrixMerkleTree<Fp> for LeafVariantMerkleTree<H> {
    fn from_matrix(matrix: &Matrix<Fp>) -> Self {
        match matrix.num_cols() {
            0 => unreachable!(),
            1 => {
                // matrix is single column so don't bother with leaf hashes
                let leaves = matrix[0].to_vec();
                Self::Unhashed(MerkleTreeImpl::new(leaves).unwrap())
            }
            _ => {
                let now = Instant::now();
                let row_hashes = utils::hash_rows::<H>(matrix);
                println!("Hashing rows: {:?}", now.elapsed());
                Self::Hashed(MerkleTreeImpl::new(row_hashes).unwrap())
            }
        }
    }

    fn verify_rows(
        root: &Self::Root,
        row_ids: &[usize],
        rows: &[impl AsRef<[Fp]>],
        proof: Self::Proof,
    ) -> Result<(), Error> {
        // remove duplicates and sort
        // TODO: little bit of duplication from MatrixMerkleTreeImpl in miniSTARK
        let mut instances = zip(row_ids, rows).collect::<Vec<_>>();
        instances.sort_unstable_by(|(a, _), (b, _)| a.cmp(b));
        instances.dedup_by(|(a, _), (b, _)| a == b);

        let (indices, rows): (Vec<_>, Vec<_>) = instances.into_iter().unzip();

        // check leaves match
        match &proof {
            LeafVariantMerkleTreeProof::Unhashed(proof) => {
                let mut initial_leaves = Vec::new();
                for row in rows {
                    match row.as_ref() {
                        &[v] => initial_leaves.push(v),
                        _ => return Err(Error::InvalidProof),
                    }
                }
                if proof.initial_leaves != initial_leaves {
                    return Err(Error::InvalidProof);
                }
            }
            LeafVariantMerkleTreeProof::Hashed(proof) => {
                let initial_leaves = rows
                    .into_iter()
                    .map(|r| H::hash_elements(r.as_ref().iter().copied()))
                    .collect::<Vec<_>>();
                if proof.initial_leaves != initial_leaves {
                    return Err(Error::InvalidProof);
                }
            }
        }

        Self::verify(root, proof, &indices)
    }
}

pub enum LeafVariantMerkleTreeProof<H: ElementHashFn<Fp>> {
    Hashed(MerkleView<H::Digest, H::Digest>),
    Unhashed(MerkleView<H::Digest, Fp>),
}

impl<H: ElementHashFn<Fp>> LeafVariantMerkleTreeProof<H> {
    const HASHED_DISCRIMINANT: u8 = 0;
    const UNHASHED_DISCRIMINANT: u8 = 1;
}

impl<H: ElementHashFn<Fp>> Clone for LeafVariantMerkleTreeProof<H> {
    fn clone(&self) -> Self {
        match self {
            Self::Hashed(proof) => Self::Hashed(proof.clone()),
            Self::Unhashed(proof) => Self::Unhashed(proof.clone()),
        }
    }
}

impl<H: ElementHashFn<Fp>> CanonicalSerialize for LeafVariantMerkleTreeProof<H> {
    fn serialize_with_mode<W: ark_serialize::Write>(
        &self,
        mut writer: W,
        compress: ark_serialize::Compress,
    ) -> Result<(), ark_serialize::SerializationError> {
        match self {
            Self::Hashed(proof) => {
                Self::HASHED_DISCRIMINANT.serialize_with_mode(&mut writer, compress)?;
                proof.serialize_with_mode(writer, compress)
            }
            Self::Unhashed(proof) => {
                Self::UNHASHED_DISCRIMINANT.serialize_with_mode(&mut writer, compress)?;
                proof.serialize_with_mode(writer, compress)
            }
        }
    }

    fn serialized_size(&self, compress: ark_serialize::Compress) -> usize {
        1 + match self {
            Self::Hashed(proof) => proof.serialized_size(compress),
            Self::Unhashed(proof) => proof.serialized_size(compress),
        }
    }
}

impl<H: ElementHashFn<Fp>> Valid for LeafVariantMerkleTreeProof<H> {
    fn check(&self) -> Result<(), ark_serialize::SerializationError> {
        Ok(())
    }
}

impl<H: ElementHashFn<Fp>> CanonicalDeserialize for LeafVariantMerkleTreeProof<H> {
    fn deserialize_with_mode<R: ark_serialize::Read>(
        mut reader: R,
        compress: ark_serialize::Compress,
        validate: ark_serialize::Validate,
    ) -> Result<Self, ark_serialize::SerializationError> {
        let variant = u8::deserialize_with_mode(&mut reader, compress, validate)?;
        Ok(match variant {
            Self::HASHED_DISCRIMINANT => {
                Self::Hashed(<_>::deserialize_with_mode(reader, compress, validate)?)
            }
            Self::UNHASHED_DISCRIMINANT => {
                Self::Unhashed(<_>::deserialize_with_mode(reader, compress, validate)?)
            }
            _ => Err(ark_serialize::SerializationError::InvalidData)?,
        })
    }
}

#[derive(Default)]
pub struct UnhashedLeafConfig<H>(PhantomData<H>);

impl<H: ElementHashFn<Fp>> MerkleTreeConfig for UnhashedLeafConfig<H> {
    type Digest = H::Digest;
    type Leaf = Fp;

    fn hash_leaves(_: u32, l0: &Fp, l1: &Fp) -> H::Digest {
        H::hash_elements([*l0, *l1])
    }

    fn hash_nodes(_: u32, n0: &H::Digest, n1: &H::Digest) -> H::Digest {
        H::merge(n0, n1)
    }

    fn security_level_bits() -> u32 {
        H::COLLISION_RESISTANCE
    }
}

#[cfg(test)]
mod tests {
    use super::FriendlyMerkleTree;
    use crate::hash::keccak::Keccak256HashFn;
    use crate::hash::pedersen::PedersenHashFn;
    use crate::merkle::LeafVariantMerkleTree;
    use ark_ff::MontFp as Fp;
    use blake2::Blake2s256;
    use digest::Output;
    use ministark::merkle::Error;
    use ministark::merkle::MatrixMerkleTree;
    use ministark::merkle::MerkleTree;
    use ministark::utils::GpuAllocator;
    use ministark::Matrix;
    use std::mem::size_of;

    #[test]
    fn leaf_variant_merkle_tree_with_single_column() -> Result<(), Error> {
        const REVEAL_INDEX: usize = 3;
        type TestMerkleTree = LeafVariantMerkleTree<Keccak256HashFn>;
        let col = [
            Fp!("0"),
            Fp!("1"),
            Fp!("2"),
            Fp!("3"),
            Fp!("4"),
            Fp!("5"),
            Fp!("6"),
            Fp!("7"),
        ];
        let matrix = Matrix::new(vec![col.to_vec_in(GpuAllocator)]);
        let merkle_tree = TestMerkleTree::from_matrix(&matrix);
        let root = merkle_tree.root();

        let proof = merkle_tree.prove_rows(&[REVEAL_INDEX])?;

        TestMerkleTree::verify(&root, proof, &[REVEAL_INDEX])
    }

    #[test]
    fn leaf_variant_merkle_tree_with_multiple_columns() -> Result<(), Error> {
        const REVEAL_INDEX: usize = 3;
        type TestMerkleTree = LeafVariantMerkleTree<Keccak256HashFn>;
        let col = [
            Fp!("0"),
            Fp!("1"),
            Fp!("2"),
            Fp!("3"),
            Fp!("4"),
            Fp!("5"),
            Fp!("6"),
            Fp!("7"),
        ];
        let matrix = Matrix::new(vec![
            col.to_vec_in(GpuAllocator),
            col.to_vec_in(GpuAllocator),
        ]);
        let merkle_tree = TestMerkleTree::from_matrix(&matrix);
        let root = merkle_tree.root();

        let proof = merkle_tree.prove_rows(&[REVEAL_INDEX])?;

        TestMerkleTree::verify(&root, proof, &[REVEAL_INDEX])
    }

    #[test]
    fn friendly_merkle_tree_with_single_column() -> Result<(), Error> {
        const REVEAL_INDEX: usize = 3;
        const N_PEDERSEN_LAYERS: u32 = 1;
        type TestMerkleTree = FriendlyMerkleTree<N_PEDERSEN_LAYERS, PedersenHashFn>;
        let col = [
            Fp!("0"),
            Fp!("1"),
            Fp!("2"),
            Fp!("3"),
            Fp!("4"),
            Fp!("5"),
            Fp!("6"),
            Fp!("7"),
        ];
        let matrix = Matrix::new(vec![col.to_vec_in(GpuAllocator)]);
        let merkle_tree = TestMerkleTree::from_matrix(&matrix);
        let root = merkle_tree.root();

        let proof = merkle_tree.prove_rows(&[REVEAL_INDEX])?;

        TestMerkleTree::verify(&root, proof, &[REVEAL_INDEX])
    }

    #[test]
    fn friendly_merkle_tree_without_pedersen() -> Result<(), Error> {
        const REVEAL_INDEX: usize = 3;
        const N_PEDERSEN_LAYERS: u32 = 0;
        type TestMerkleTree = FriendlyMerkleTree<N_PEDERSEN_LAYERS, PedersenHashFn>;
        let col = [
            Fp!("0"),
            Fp!("1"),
            Fp!("2"),
            Fp!("3"),
            Fp!("4"),
            Fp!("5"),
            Fp!("6"),
            Fp!("7"),
        ];
        let matrix = Matrix::new(vec![
            col.to_vec_in(GpuAllocator),
            col.to_vec_in(GpuAllocator),
        ]);
        let merkle_tree = TestMerkleTree::from_matrix(&matrix);
        let root = merkle_tree.root();

        let proof = merkle_tree.prove_rows(&[REVEAL_INDEX])?;

        TestMerkleTree::verify(&root, proof, &[REVEAL_INDEX])
    }

    #[test]
    fn friendly_merkle_tree_with_single_pedersen_layer() -> Result<(), Error> {
        const REVEAL_INDEX: usize = 3;
        const N_PEDERSEN_LAYERS: u32 = 1;
        type TestMerkleTree = FriendlyMerkleTree<N_PEDERSEN_LAYERS, PedersenHashFn>;
        let col = [
            Fp!("0"),
            Fp!("1"),
            Fp!("2"),
            Fp!("3"),
            Fp!("4"),
            Fp!("5"),
            Fp!("6"),
            Fp!("7"),
        ];
        let matrix = Matrix::new(vec![
            col.to_vec_in(GpuAllocator),
            col.to_vec_in(GpuAllocator),
        ]);
        let merkle_tree = TestMerkleTree::from_matrix(&matrix);
        let root = merkle_tree.root();

        let proof = merkle_tree.prove_rows(&[REVEAL_INDEX])?;

        TestMerkleTree::verify(&root, proof, &[REVEAL_INDEX])
    }

    #[test]
    fn friendly_merkle_tree_with_multiple_pedersen_layers() -> Result<(), Error> {
        const REVEAL_INDEX: usize = 3;
        const N_PEDERSEN_LAYERS: u32 = 3;
        type TestMerkleTree = FriendlyMerkleTree<N_PEDERSEN_LAYERS, PedersenHashFn>;
        let col = [
            Fp!("0"),
            Fp!("1"),
            Fp!("2"),
            Fp!("3"),
            Fp!("4"),
            Fp!("5"),
            Fp!("6"),
            Fp!("7"),
        ];
        let matrix = Matrix::new(vec![
            col.to_vec_in(GpuAllocator),
            col.to_vec_in(GpuAllocator),
        ]);
        let merkle_tree = TestMerkleTree::from_matrix(&matrix);
        let root = merkle_tree.root();

        let proof = merkle_tree.prove_rows(&[REVEAL_INDEX])?;

        TestMerkleTree::verify(&root, proof, &[REVEAL_INDEX])
    }

    #[test]
    fn friendly_merkle_tree_with_multi_row_decommitment() -> Result<(), Error> {
        const REVEAL_INDICES: &[usize] = &[1, 3, 7];
        const N_PEDERSEN_LAYERS: u32 = 2;
        type TestMerkleTree = FriendlyMerkleTree<N_PEDERSEN_LAYERS, PedersenHashFn>;
        let col = [
            Fp!("0"),
            Fp!("1"),
            Fp!("2"),
            Fp!("3"),
            Fp!("4"),
            Fp!("5"),
            Fp!("6"),
            Fp!("7"),
        ];
        let matrix = Matrix::new(vec![
            col.to_vec_in(GpuAllocator),
            col.to_vec_in(GpuAllocator),
        ]);
        let merkle_tree = TestMerkleTree::from_matrix(&matrix);
        let root = merkle_tree.root();

        let proof = merkle_tree.prove_rows(REVEAL_INDICES)?;

        TestMerkleTree::verify(&root, proof, REVEAL_INDICES)
    }

    #[test]
    fn print_size() {
        println!("Size of hash {}", size_of::<Output<Blake2s256>>());
    }
}
